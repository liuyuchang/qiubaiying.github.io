---
layout:     post   				    # 使用的布局（不需要改）
title:      Solution for luogu 1031 				# 标题 
subtitle:   the world of algorithm #副标题
date:       2018-04-11 				# 时间
author:     LYC 						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 贪心
---

# 递归+贪心

[洛谷1031](https://www.luogu.org/problemnew/show/P1031)

蒟篛看到没有人用递归，虽然是小技巧。。。

于是在本蒟蒻多次提交其他题目不是WA就是超时的背景下，终于A了一题，决定发一波题解。本题解详细解说，属于蒟篛（比如我）友好型


## 首先我们考虑最终情况

由于纸牌数可以被n整除，所以最后每一堆必然是总纸牌数的平均数。


1. 于是我们考虑将初始纸牌数与平均数的差值存进数组，记为A1,A2...An

2. 因为只能左右移动，所以Ai（1<i<n）必须通过与Ai-1或Ai+1值的改变来达到**0**值（即达到平均值）

3. 所以，鱿鱼左边移右边移的对称性，我们把Ai（1<=i<n）的值加到Ai+1,同时计数器+1，将Ai的值置0。然后这个过程递归地向右进行。

### 需要注意的是，因为有可能某些堆初始纸牌数与平均数相等，我们并不需要对他们处理。

代码:

```
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int a[105];
int sum,total;//total为计数器 
void work(int i,int j)
{
    if(i==j)return;//到达递归边界，return 
    while(a[i]==0)i++;//注1 
    a[i+1]+=a[i];
    total++;
    a[i]=0;
    work(i+1,j);//递归调用 
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        sum+=a[i];
    }
    sum=sum/n;//获得平均数 
    for(int i=1;i<=n;i++) a[i]=a[i]-sum;
    int i=1,j=n;
    while(a[i]==0)//===1=== 
    {
        i++;
        if(i==j+1)//如果纸牌一开始就不需要移动 
        {
            cout<<"0";
            return 0;
            /*虽然我不知道会不会有这样的数据卡我们
            但是刘汝佳说：要把程序写的更鲁棒*/ 
        }
    }
    while(a[j]==0)j--;//===2===
    /* 1  和  2 都是用来把两边的0去掉*/
    work(i,j);
    cout<<total;
    return 0;
}
```

注1：为什么要while(a[i]==0)i++;呢？

因为  for example

运行中如果A数组出现

3  5  -5  -1  -2  这种情况

注意到 5  -5是相反数，把5加到-5时，不仅5变成了0，连-5也变成了0，所以为了避免total变大，需要跳过0.


以上
