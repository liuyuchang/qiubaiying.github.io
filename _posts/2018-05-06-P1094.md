---
layout:     post   				    # 使用的布局（不需要改）
title:      洛谷1094题解 				# 标题 
subtitle:   算法的世界 #副标题
date:       2018-05-06			# 时间
author:     LYC					# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:  贪心

---

## 题目描述

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。

你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。
## 输入输出格式
#### 输入格式：

输入文件group.in包含n+2行:

第1行包括一个整数w，为每组纪念品价格之和的上上限。

第2行为一个整数n，表示购来的纪念品的总件数G

第3~n+2行每行包含一个正整数Pi (5 <= Pi <= w)表示所对应纪念品的价格。

#### 输出格式：

输出文件group.out仅一行，包含一个整数，即最少的分组数目。

------------

#### 输入输出样例

输入样例#1：

```
100 
9 
90 
20 
20 
30 
50 
60 
70 
80 
90
```

输出样例#1： 

```
6
```

## 分析与做法

- 最少的分组数目与输入的顺序无关，考虑排序。

- 从后往前扫描，直至到没有放入背包的。此时另外设置一个指针，从此处向前扫描，直至遇到没有放入背包的，如果不超过最大限制，放入背包，同时背包数加一；否则继续。

## 算法的正确性证明

- 观察最大的数，显然：如果它与最小的数都不能装入一个背包，它必须单独放。

- 如果可以与其它数一起放入一个背包，那么应该和谁一起呢？注意到不管和谁在一起，它们都占用了一个背包，也就是说，对答案是等效的。此时需要贪心的使剩下的状态获得最优。显然，与合法的数中最大的那个放在一起即可。

----------

代码如下：

```
#include<stdio.h>
#include<iostream>
#include<string.h>
#include<string>
#include<algorithm>
#define HOME
#define MAXN 30005
using namespace std;

int a[MAXN];
int sum;
bool b[MAXN];

inline void TEST(string ch,int i)
{
    cout<<"test: "<<ch<<"="<<i<<endl;
    system("pause");
}

int main()
{
#ifdef NOIP
    freopen(".in","r",stdin);
    freopen(".out","w",stdout);
#endif

    memset(b,true,sizeof(b));
    int w,n;
    scanf("%d%d",&w,&n);
    
    for(int i=1;i<=n;i++)
     scanf("%d",&a[i]);
    
    sort(a+1,a+1+n);
    
    /*
    //====test=====
    for(int i=1;i<=n;i++)
    printf("%d ",a[i]);
    return 0;
    //====test=====
    */
    
    bool flag=false;
    for(int i=n;i>1;i--)
    {
    	//TEST("i",i);
    	//TEST("sum",sum);
        if(!b[i])continue;
        flag=false;
        for(int j=i-1;j>=1;j--)
        {
            if(a[i]+a[j]<=w && b[j]){
                sum++;
                b[i]=b[j]=false;
                flag=true;
                break;
            }
        }
        if(!flag){
            sum++;
            b[i]=false;
        }
    }	
    if(b[1]) sum++;
    printf("%d",sum);
    
    return 0;
}
```

> END
